{"version":3,"sources":["../src/index.ts","../src/lib/operators.ts","../src/lib/utils.ts","../src/builder.ts","../src/parser.ts"],"sourcesContent":["export * from './lib';\nexport * from './builder';\nexport * from './parser';\n","import isEqual from 'lodash/isequal';\nimport { FilterOperator, OperatorFn } from './types';\n\nconst buildLikeRegex = (search: string) =>\n  new RegExp(`^${search.replace(/%/g, '.*')}$`);\n\nconst textSearch: OperatorFn = (c, v) => {\n  const regExp = `^${v\n    .split('&')\n    .map((v: string) => v.trim().toLowerCase())\n    .join('|')\n    .replace(/:\\*/g, '.*')}$`;\n  const tokens = c\n    .match(/'(.*?)'/g)\n    .map((t: string) => t.replace(/'/g, '').toLowerCase());\n  return tokens.some((t: string) => new RegExp(regExp).test(t));\n};\n\nconst ifDateGetTime = (v: any) => (v instanceof Date ? v.getTime() : v);\n\nexport const OPERATOR_MAP: { [Key in FilterOperator]?: OperatorFn } = {\n  eq: (c, v) => ifDateGetTime(c) === ifDateGetTime(v),\n  neq: (c, v) => ifDateGetTime(c) !== ifDateGetTime(v),\n  gt: (c, v) => c > v,\n  gte: (c, v) => c >= v,\n  lt: (c, v) => c < v,\n  lte: (c, v) => c <= v,\n  like: (c, v) => buildLikeRegex(v).test(c.toString()),\n  ilike: (c, v) =>\n    buildLikeRegex(v.toLowerCase()).test(c.toString().toLowerCase()),\n  is: (c, v) => c === v,\n  in: (c, v) => {\n    const parsedValue = v.slice(1, -1).split(',');\n    return parsedValue.some((i: string) => i === c);\n  },\n  // contains\n  cs: (c, v) => {\n    if (!Array.isArray(c)) return false;\n    if (!Array.isArray(v)) v = v.slice(1, -1).split(',');\n    return v.every((i: string) => c.some((colVal) => isEqual(colVal, i)));\n  },\n  // containedBy\n  cd: (c, v) => {\n    if (!Array.isArray(c)) return false;\n    if (!Array.isArray(v)) v = v.slice(1, -1).split(',');\n    return c.every((i: string) => v.some((cmpVal: any) => isEqual(cmpVal, i)));\n  },\n  fts: textSearch,\n  plfts: (c, v) =>\n    buildLikeRegex(v.toLowerCase()).test(c.toString().toLowerCase()),\n};\n\nexport const SUPPORTED_OPERATORS = ['or', ...Object.keys(OPERATOR_MAP)];\n","import { ValueType } from './types';\n\n/**\n * Check if a value is a valid ISO DateTime string\n * @param v\n * @returns\n */\nexport const isISODateString = (v: unknown): boolean =>\n  typeof v === 'string' &&\n  /(\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d\\.\\d+([+-][0-2]\\d:[0-5]\\d|Z))|(\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d([+-][0-2]\\d:[0-5]\\d|Z))|(\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d([+-][0-2]\\d:[0-5]\\d|Z))/.test(\n    v\n  );\n\n/**\n * Safely parse any value to a ValueType\n * @param v\n * @returns\n */\nexport const parseValue = (v: any): ValueType => {\n  if (isISODateString(v)) return new Date(v);\n  try {\n    return JSON.parse(v);\n  } catch {\n    return v;\n  }\n};\n\n/**\n *\n * @param i Ahhh gotta love typescript\n * @returns\n */\nexport const isNotNull = <I>(i: I | null): i is I => i !== null;\n","import get from 'lodash/get';\nimport {\n  FilterDefinition,\n  FilterDefinitions,\n  FilterFn,\n  OperatorFn,\n  OPERATOR_MAP,\n  parseValue,\n  ValueType,\n} from './lib';\n\nexport class PostgrestFilterFnBuilder<Type> {\n  private _fn: FilterFn<Type> | undefined;\n  private _selectFn: FilterFn<Type> | undefined;\n  private _filtersFn: FilterFn<Type> | undefined;\n\n  constructor(\n    public readonly query: { paths: string[]; filters: FilterDefinitions }\n  ) {}\n\n  get fn(): FilterFn<Type> {\n    if (!this._fn) {\n      this._fn = (obj): obj is Type =>\n        this.filtersFn(obj) && this.selectFn(obj);\n    }\n    return this._fn;\n  }\n\n  get filtersFn(): FilterFn<Type> {\n    if (!this._filtersFn) {\n      const filterFns = this.query.filters.map((d) => this.buildFilterFn(d));\n      this._filtersFn = (obj): obj is Type => filterFns.every((fn) => fn(obj));\n    }\n    return this._filtersFn;\n  }\n\n  get selectFn(): FilterFn<Type> {\n    if (!this._selectFn) {\n      this._selectFn = (obj): obj is Type =>\n        this.query.paths.every((p) => typeof get(obj, p) !== 'undefined');\n    }\n    return this._selectFn;\n  }\n\n  private applyFilterFn(\n    obj: Record<string, unknown>,\n    path: string,\n    {\n      filterFn,\n      value,\n      negate,\n    }: { filterFn: OperatorFn; value: ValueType; negate: boolean }\n  ): boolean {\n    const pathElements = path.split('.');\n    const v = obj[pathElements[0]];\n\n    if (typeof v === 'undefined') return false;\n\n    if (pathElements.length > 1) {\n      // recursively resolve json path\n      if (Array.isArray(v)) {\n        return v.some((val) =>\n          this.applyFilterFn(val, pathElements.slice(1).join('.'), {\n            filterFn,\n            value,\n            negate,\n          })\n        );\n      }\n      return this.applyFilterFn(\n        v as Record<string, unknown>,\n        pathElements.slice(1).join('.'),\n        {\n          filterFn,\n          value,\n          negate,\n        }\n      );\n    }\n\n    const res = filterFn(parseValue(v), value);\n    if (negate) return !res;\n    return res;\n  }\n\n  private buildFilterFn(\n    def:\n      | FilterDefinition\n      | { or: FilterDefinitions }\n      | { and: FilterDefinitions }\n  ): (obj: Record<string, unknown>) => boolean {\n    if ('or' in def) {\n      return (obj: Record<string, unknown>) =>\n        def.or.some((d) => this.buildFilterFn(d)(obj));\n    }\n    if ('and' in def) {\n      return (obj: Record<string, unknown>) =>\n        def.and.every((d) => this.buildFilterFn(d)(obj));\n    }\n    const { operator, path, value, negate } = def;\n    const filterFn = OPERATOR_MAP[operator];\n    if (!filterFn) throw new Error(`Operator ${operator} is not supported`);\n\n    return (obj: Record<string, unknown>) =>\n      this.applyFilterFn(obj, path, { filterFn, value, negate });\n  }\n}\n","import XRegExp from 'xregexp';\nimport {\n  FilterDefinition,\n  FilterDefinitions,\n  FilterOperator,\n  isNotNull,\n  parseValue,\n  SUPPORTED_OPERATORS,\n} from './lib';\nimport { PostgrestFilterFnBuilder } from './builder';\n\nexport type PostgrestQueryParserOptions = {\n  /**\n   * If defined, will use only filters that apply to the given paths\n   */\n  exclusivePaths?: string[];\n};\n\nexport class PostgrestQueryParser {\n  private _filters: FilterDefinitions | undefined;\n  private _paths: string[] | undefined;\n\n  constructor(\n    public readonly params: URLSearchParams,\n    public readonly opts?: PostgrestQueryParserOptions\n  ) {}\n\n  get builder() {\n    return new PostgrestFilterFnBuilder({\n      filters: this.filters,\n      paths: this.paths,\n    });\n  }\n\n  get paths(): string[] {\n    if (!this._paths) {\n      this._paths = this.parseSelectParam();\n    }\n    return this._paths;\n  }\n\n  get filters(): FilterDefinitions {\n    if (!this._filters) {\n      const filters: FilterDefinitions = [];\n      this.params.forEach((value, key) => {\n        if (\n          SUPPORTED_OPERATORS.some(\n            (f) => key === f || value.split('.').includes(f)\n          )\n        ) {\n          const filter = this.parseFilterString(`${key}.${value}`, undefined);\n          if (filter !== null) filters.push(filter);\n        }\n      });\n      this._filters = filters;\n    }\n\n    return this._filters;\n  }\n\n  private parseSelectParam(s?: string, currentPath?: string): string[] {\n    if (!s) s = this.params.get('select') ?? undefined;\n    if (!s) return [];\n\n    const foreignTables = XRegExp.matchRecursive(\n      `,${s}`,\n      ',[^,]*\\\\(',\n      '\\\\)',\n      'g',\n      {\n        valueNames: {\n          '0': null,\n          '1': 'tableName',\n          '2': 'selectedColumns',\n          '3': null,\n        },\n      }\n    ).reduce((prev, curr, idx, matches) => {\n      if (curr.name === 'selectedColumns') {\n        const name = matches[idx - 1].value.slice(1, -1);\n        prev = { ...prev, [name]: curr.value };\n      }\n      return prev;\n    }, {});\n\n    const columns = s\n      .replace(\n        new RegExp(\n          `${Object.entries(foreignTables)\n            .map(([table, selectedColumns]) =>\n              `${table}(${selectedColumns})`\n                .replace(/\\(/g, '\\\\(')\n                .replace(/\\)/g, '\\\\)')\n            )\n            .join('|')}`,\n          'g'\n        ),\n        ''\n      )\n      .replace(/(,)\\1+/g, ',')\n      .split(',')\n      .filter((c) => c.length > 0)\n      .map((c) => c.split(':').shift());\n\n    if (columns.includes('*'))\n      throw new Error('Wildcard selector is not supported');\n\n    return [\n      ...columns.map((c) =>\n        [currentPath, c && c.split(':').shift()].filter(Boolean).join('.')\n      ),\n      ...Object.entries(foreignTables).flatMap(([table, selectedColumns]) =>\n        this.parseSelectParam(\n          `${selectedColumns}`,\n          [currentPath, table.split(':').shift()?.split('!').shift()]\n            .filter(Boolean)\n            .join('.')\n        )\n      ),\n    ];\n  }\n\n  private parseFilterString(\n    filter: string,\n    prefix?: string\n  ):\n    | FilterDefinition\n    | { or: FilterDefinitions }\n    | { and: FilterDefinitions }\n    | null {\n    if (filter.startsWith('and(') && filter.endsWith(')')) {\n      // nested and\n      const andFilters = filter\n        .slice(4, -1)\n        .split(',')\n        .map((s) => this.parseFilterString(s, prefix))\n        .filter(isNotNull);\n      if (andFilters.length === 0) return null;\n      else return { and: andFilters };\n    }\n\n    const split = filter.split('.');\n\n    // or\n    if ([split[0], split[1]].includes('or')) {\n      let foreignTable: string | undefined;\n      if (split[1] === 'or') {\n        // with foreign table\n        foreignTable = split[0];\n      }\n\n      const orFilters = filter\n        .slice(4 + (foreignTable ? foreignTable.length + 1 : 0), -1)\n        .split(',')\n        .reduce<string[]>((prev, curr, idx, filters) => {\n          if (curr.startsWith('and(')) {\n            // nested and\n            prev = [...prev, [curr, filters[idx + 1]].join()];\n          } else if (!curr.endsWith(')')) {\n            prev = [...prev, curr];\n          }\n          return prev;\n        }, [])\n        .map((s) => this.parseFilterString(s, foreignTable))\n        .filter(isNotNull);\n      if (orFilters.length === 0) return null;\n      else return { or: orFilters };\n    }\n\n    const path = [prefix, split[0]]\n      .filter(Boolean)\n      .join('.')\n      .replace(/\\s/g, '')\n      .replace(/->>|->/g, '.');\n\n    if (\n      Array.isArray(this.opts?.exclusivePaths) &&\n      !this.opts?.exclusivePaths.includes(path)\n    ) {\n      return null;\n    }\n\n    const negate = split[1] === 'not';\n    const operator = (negate ? split[2] : split[1]) as FilterOperator;\n    const value = (negate ? split.slice(3) : split.slice(2)).join('.');\n    return {\n      path,\n      negate,\n      operator,\n      value: parseValue(value),\n    };\n  }\n}\n"],"mappings":"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","names":["v","isEqual","get","XRegExp","_a"]}